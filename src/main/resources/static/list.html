<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>KEEHIN REPORT LIST - TREE MODE</title>
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap");

            body {
                background-color: #f4f7f6;
                color: #2c3e50;
                font-family: "Fira Code", monospace;
                margin: 0;
                padding: 30px;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #tree-container {
                width: 95%;
                max-width: 1200px;
                background-color: #ffffff;
                border: 1px solid #dcdde1;
                border-radius: 8px;
                padding: 25px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                white-space: pre;
                overflow-x: auto;
                font-size: 14px;
                line-height: 1.6;
            }

            .header {
                width: 95%;
                max-width: 1200px;
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                font-weight: bold;
                border-bottom: 2px solid #2c3e50;
                padding-bottom: 10px;
            }

            .path-info {
                color: #34495e;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <span>DIRECTORY STRUCTURE</span>
            <span>DATE / SIZE</span>
        </div>
        <pre id="tree-container">INITIALIZING DIRECTORY SCAN...</pre>

        <script>
            const treeContainer = document.getElementById("tree-container")

            function pad(str, length, char = " ") {
                str = String(str || "")
                return str.padEnd(length, char)
            }

            function rightJustify(mainText, metadata, totalWidth) {
                const spaces = totalWidth - mainText.length - metadata.length
                return mainText + (spaces > 0 ? " ".repeat(spaces) : "  ") + metadata
            }

            function buildTree(data) {
                const root = { name: "ROOT", items: {}, isDir: true }
                data.forEach((item) => {
                    if (item.file === "/") return
                    const parts = item.file.split(/[/\\]/)
                    let current = root
                    parts.forEach((part, index) => {
                        if (!part) return
                        if (!current.items[part]) {
                            current.items[part] = {
                                name: part,
                                items: {},
                                isDir: item.isDir === "true" || item.size === undefined,
                                metadata: index === parts.length - 1 ? item : null,
                            }
                        }
                        current = current.items[part]
                    })
                })
                return root
            }

            function renderTree(node, prefix = "", isLast = true, depth = 0) {
                let output = ""
                const TOTAL_WIDTH = 145

                if (depth > 0) {
                    const branch = isLast ? "└── " : "├── "
                    let line = prefix + branch
                    if (node.isDir) {
                        line += "# " + node.name
                    } else {
                        line +=
                            node.name +
                            (node.metadata?.report ? " (" + node.metadata.report + ")" : "")
                    }

                    let metadataStr = ""
                    if (node.metadata && !node.isDir) {
                        metadataStr =
                            pad(node.metadata.updated, 20) +
                            " " +
                            pad(node.metadata.size + "K", 8, " ")
                    }
                    output += rightJustify(line, metadataStr, TOTAL_WIDTH) + "\n"
                } else {
                    output += "/khgroup/report/\n"
                }

                const nextPrefix = depth === 0 ? "" : prefix + (isLast ? "    " : "│   ")
                const childKeys = Object.keys(node.items).sort()
                childKeys.forEach((key, index) => {
                    output += renderTree(
                        node.items[key],
                        nextPrefix,
                        index === childKeys.length - 1,
                        depth + 1,
                    )
                })
                return output
            }

            async function fetchAndRenderReports() {
                try {
                    const response = await fetch("json")
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`)

                    const data = await response.json()
                    if (!data || data.length === 0) {
                        treeContainer.textContent = "NO REPORTS FOUND."
                        return
                    }

                    const tree = buildTree(data)
                    treeContainer.textContent = renderTree(tree)
                } catch (error) {
                    treeContainer.textContent =
                        "ERROR: FAILED TO LOAD DIRECTORY STRUCTURE\n" + error.message
                    console.error("Error fetching report data:", error)
                }
            }

            document.addEventListener("DOMContentLoaded", fetchAndRenderReports)
        </script>
    </body>
</html>
